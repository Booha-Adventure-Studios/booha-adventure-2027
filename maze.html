
<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Booha Adventure 2027 â€” Maze</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Bowlby+One&display=swap" rel="stylesheet" />
  <style>
    :root{
      --pink:#ff3bbd; --pink2:#ff79d7;
      --blue:#3bc8ff; --blue2:#79dfff;
      --safe-top:    env(safe-area-inset-top);
      --safe-right:  env(safe-area-inset-right);
      --safe-bottom: env(safe-area-inset-bottom);
      --safe-left:   env(safe-area-inset-left);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; background:#000; color:#fff;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,
        "Noto Sans","Hiragino Kaku Gothic ProN","Yu Gothic",sans-serif; }
    #app{ position:fixed; inset:0; background:#000; overflow:hidden; }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       ROTATE OVERLAY
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #rotateOverlay{
      position:fixed; inset:0;
      display:none; flex-direction:column;
      align-items:center; justify-content:center; gap:20px;
      background:#000; z-index:9999; text-align:center; padding:32px;
    }
    #rotateOverlay.show{ display:flex; }
    .rotateIcon{ font-size:68px; display:block; transform-origin:center;
      animation:rotateHint 2.2s ease-in-out infinite; }
    @keyframes rotateHint{
      0%  { transform:rotate(0deg); }
      35% { transform:rotate(-90deg); }
      65% { transform:rotate(-90deg); }
      100%{ transform:rotate(0deg); }
    }
    .rotateTitle{ font-family:'Bowlby One',sans-serif;
      font-size:clamp(20px,5vw,28px); letter-spacing:2px; color:#fff; margin:0;
      text-shadow:0 0 30px rgba(255,140,255,.7),0 0 60px rgba(255,80,200,.35); }
    .rotateSub{ font-size:15px; color:rgba(255,255,255,.6); margin:0; line-height:1.6; }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SHARED OVERLAY BASE
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    .overlay{
      position:absolute; inset:0;
      display:flex; flex-direction:column;
      align-items:center; justify-content:center;
      gap:clamp(14px,3.5vmin,30px);
      padding:
        calc(28px + var(--safe-top))
        calc(28px + var(--safe-right))
        calc(28px + var(--safe-bottom))
        calc(28px + var(--safe-left));
      background:radial-gradient(ellipse at center,
        rgba(0,0,0,.50) 0%,rgba(0,0,0,.84) 62%,rgba(0,0,0,.97) 100%);
      backdrop-filter:blur(6px); -webkit-backdrop-filter:blur(6px);
      text-align:center; z-index:40;
      transition:opacity 550ms ease;
    }
    .overlay.hidden{ opacity:0; pointer-events:none; }
    .overlay.gone  { display:none; }

    .overlayHeading{
      font-family:'Bowlby One',sans-serif;
      font-size:clamp(20px,4.5vw,46px);
      letter-spacing:2px; margin:0; color:#fff; line-height:1.2;
      text-shadow:
        0 0 32px rgba(255,140,255,.7),
        0 0 80px rgba(255,80,200,.35),
        0 2px 8px rgba(0,0,0,.9);
    }
    .btnRow{
      display:flex; gap:clamp(10px,3vmin,20px);
      flex-wrap:wrap; justify-content:center; align-items:center;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       OVERLAY BUTTONS
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    .btnPink, .btnBlue{
      appearance:none; border:0; border-radius:999px;
      padding:clamp(11px,2.5vmin,15px) clamp(20px,5vmin,30px);
      font-size:clamp(15px,3.8vmin,20px); font-weight:1000; letter-spacing:.5px;
      cursor:pointer; color:#000;
      -webkit-tap-highlight-color:transparent; transform:translateZ(0);
      min-width:80px;
    }
    .btnPink{
      background:linear-gradient(180deg,var(--pink2),var(--pink));
      box-shadow:
        0 8px 20px rgba(255,59,189,.28),
        0 0 0 2px rgba(255,59,189,.18),
        0 0 26px rgba(255,59,189,.38);
    }
    .btnPink:active{ transform:scale(.96); }
    .btnBlue{
      background:linear-gradient(180deg,var(--blue2),var(--blue));
      box-shadow:
        0 8px 20px rgba(59,200,255,.28),
        0 0 0 2px rgba(59,200,255,.18),
        0 0 26px rgba(59,200,255,.38);
    }
    .btnBlue:active{ transform:scale(.96); }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SPARKLES
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    .sparkleWrap{
      position:relative; display:inline-flex;
      align-items:center; justify-content:center;
    }
    .sparkleField{ position:absolute; inset:-50px; pointer-events:none; }
    .sp{
      position:absolute; border-radius:50%; background:#fff; opacity:0;
      animation:sparkleLife var(--dur) ease-in-out var(--delay) infinite;
      width:var(--size); height:var(--size); top:var(--y); left:var(--x);
      box-shadow:
        0 0 4px 1px rgba(255,255,255,.9),
        0 0 10px 3px rgba(255,100,220,.6);
    }
    @keyframes sparkleLife{
      0%  { opacity:0;   transform:scale(.4) translateY(0); }
      20% { opacity:1;   transform:scale(1)  translateY(-6px); }
      60% { opacity:.85; transform:scale(.9) translateY(-14px); }
      100%{ opacity:0;   transform:scale(.3) translateY(-22px); }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       OVERLAY 1 â€” confirmation
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #overlay1{ z-index:50; }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       TRANSITION VIDEO
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #videoWrap{
      position:absolute; inset:0;
      display:none; background:#000; z-index:20;
    }
    #videoWrap.show{ display:block; }
    #toMazeVideo{ width:100%; height:100%; object-fit:cover; background:#000; }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       OVERLAY 2 â€” ghost start
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #overlay2{ z-index:45; display:none; }
    #overlay2.show{ display:flex; }

    /* Ghost is the button */
    .ghostBtnWrap{
      position:relative;
      display:inline-flex; align-items:center; justify-content:center;
      background:none; border:none; padding:0;
      cursor:pointer; -webkit-tap-highlight-color:transparent;
    }
    .ghostBtnWrap:active #startGhost{
      transform:scale(.88) translateY(-5px);
      filter:
        drop-shadow(0 0 44px rgba(255,100,220,1))
        drop-shadow(0 14px 30px rgba(0,0,0,.7));
    }
    .ghostSparkleField{
      position:absolute; inset:-70px;
      pointer-events:none; z-index:0;
    }
    .ghostSparkleField .sp{
      box-shadow:
        0 0 6px 2px rgba(255,255,255,.95),
        0 0 16px 5px rgba(255,100,220,.75);
    }
    #startGhost{
      /* Scales with the shorter viewport dimension â€” good in landscape */
      width:  clamp(100px, 28vmin, 200px);
      height: clamp(100px, 28vmin, 200px);
      object-fit:contain; user-select:none; -webkit-user-drag:none;
      filter:
        drop-shadow(0 0 26px rgba(255,100,220,.6))
        drop-shadow(0 14px 30px rgba(0,0,0,.7));
      animation:floaty 3.6s ease-in-out infinite;
      transform-origin:50% 60%;
      transition:transform 120ms ease, filter 120ms ease;
      position:relative; z-index:1;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       MAZE SCENE
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #mazeScene{ position:absolute; inset:0; background:#000; }

    /*
      STAGE fills the entire screen â€” no bottom reserve.
      The floating back button overlays the corner but never
      obscures the maze centre where gameplay happens.
    */
    #stage{
      position:absolute;
      top:    var(--safe-top,   0px);
      right:  var(--safe-right, 0px);
      bottom: var(--safe-bottom,0px);
      left:   var(--safe-left,  0px);
      display:flex; align-items:center; justify-content:center;
      /* tiny pad so the maze never literally touches the notch */
      padding:4px;
    }

    #mazeImg{
      /* contain = full maze always visible, no cropping */
      display:block;
      width:100%; height:100%;
      max-width:100%; max-height:100%;
      object-fit:contain;
      user-select:none; -webkit-user-drag:none;
      pointer-events:none;
    }

    /* Hit layer â€” JS positions it to match rendered maze rect */
    #hitLayer{
      position:absolute; left:0; top:0; width:0; height:0;
      cursor:default; z-index:5; pointer-events:auto;
    }

    /* Dev grid + crosshair (Bryan mode) */
    #grid{
      position:absolute; inset:0; display:none; pointer-events:none;
      background-image:
        linear-gradient(to right, rgba(255,255,255,.12) 1px, transparent 1px),
        linear-gradient(to bottom,rgba(255,255,255,.12) 1px, transparent 1px);
      background-size:80px 80px; mix-blend-mode:screen; opacity:.55;
    }
    #grid.show{ display:block; }
    #crosshair{ position:absolute; inset:0; pointer-events:none; display:none; }
    #crosshair.show{ display:block; }
    .chLineH,.chLineV{
      position:absolute; background:rgba(255,255,255,.7);
      box-shadow:0 0 16px rgba(255,255,255,.25);
    }
    .chLineH{ height:1px; left:0; right:0; top:0; }
    .chLineV{ width:1px;  top:0; bottom:0; left:0; }

    /* â”€â”€ HUD (desktop only) â”€â”€ */
    .hudTitle{
      font-family:'Bowlby One',sans-serif; font-size:clamp(13px,1.8vw,18px);
      letter-spacing:2px; line-height:1.15; color:#fff;
      text-shadow:
        0 0 22px rgba(255,140,255,.7),
        0 0 60px rgba(255,80,200,.35),
        0 2px 6px rgba(0,0,0,.9);
      user-select:none; pointer-events:none;
    }
    #hud{
      position:absolute;
      left:calc(12px + var(--safe-left)); top:calc(12px + var(--safe-top));
      display:flex; gap:10px; align-items:flex-start; z-index:10;
    }
    .pill{
      border-radius:999px; padding:10px 14px; font-weight:900; letter-spacing:.4px;
      background:rgba(0,0,0,.28); border:1px solid rgba(255,255,255,.16);
      backdrop-filter:blur(14px) saturate(140%);
      -webkit-backdrop-filter:blur(14px) saturate(140%);
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.08),
        0 14px 30px rgba(0,0,0,.35);
      color:rgba(255,255,255,.92); user-select:none;
    }
    #coordPill{ display:none; } #coordPill.show{ display:block; }
    .coordSmall{ font-size:12px; color:rgba(255,255,255,.7); font-weight:800; letter-spacing:1px; }
    .coordBig  { font-size:14px; margin-top:4px; }

    /* â”€â”€ Floating ghost avatar (desktop top-right) â”€â”€ */
    #avatar{
      position:absolute;
      right:calc(10px + var(--safe-right)); top:calc(10px + var(--safe-top));
      width:48px; height:48px; z-index:10; pointer-events:none;
      filter:drop-shadow(0 8px 16px rgba(0,0,0,.55));
      opacity:.95; transform-origin:50% 60%;
      animation:floaty 3.8s ease-in-out infinite;
    }
    @keyframes floaty{
      0%  { transform:translateY(0px)  rotate(var(--r,0deg)); }
      50% { transform:translateY(-8px) rotate(calc(var(--r,0deg) + 2deg)); }
      100%{ transform:translateY(0px)  rotate(var(--r,0deg)); }
    }

    /* â”€â”€ BRYAN button (desktop bottom-left) â”€â”€ */
    #bryanBtn{
      position:absolute;
      left:calc(10px + var(--safe-left)); bottom:calc(10px + var(--safe-bottom));
      z-index:20; border-radius:999px;
      padding:6px 10px; font-size:9px; font-weight:1000; letter-spacing:1.4px;
      text-transform:uppercase; color:rgba(255,255,255,.45);
      background:rgba(0,0,0,.30); border:1px solid rgba(255,255,255,.10);
      backdrop-filter:blur(10px) saturate(140%);
      -webkit-backdrop-filter:blur(10px) saturate(140%);
      cursor:pointer; -webkit-tap-highlight-color:transparent;
    }
    #bryanBtn.on{
      color:#fff; border-color:rgba(255,255,255,.22);
      box-shadow:0 0 0 2px rgba(255,59,189,.18),0 0 18px rgba(255,59,189,.25);
    }
    #bryanBtn:active{ transform:scale(.96); }

    /*
      â”€â”€ BACK BUTTON â”€â”€
      On mobile: small, semi-transparent, bottom-right corner, doesn't obscure maze.
      On desktop: slightly larger.
    */
    #backBtn{
      position:absolute;
      right:  calc(10px + var(--safe-right));
      bottom: calc(10px + var(--safe-bottom));
      z-index:20;
      appearance:none; border:0; border-radius:999px;
      /* mobile-first sizing */
      padding:7px 14px;
      font-size:12px; font-weight:1000; letter-spacing:.5px;
      cursor:pointer; color:#000;
      background:linear-gradient(180deg,var(--pink2),var(--pink));
      box-shadow:
        0 5px 14px rgba(255,59,189,.28),
        0 0 0 2px rgba(255,59,189,.15),
        0 0 18px rgba(255,59,189,.32);
      /* semi-transparent on mobile so it feels lighter on the maze */
      opacity:0.82;
      -webkit-tap-highlight-color:transparent; transform:translateZ(0);
      transition:opacity 200ms;
    }
    #backBtn:hover { opacity:1; }
    #backBtn:active{ transform:scale(.96); opacity:1; }

    /* Desktop: a bit bigger */
    @media (min-width:900px) and (pointer:fine){
      #backBtn{ padding:9px 18px; font-size:14px; opacity:1; }
      #bryanBtn{ padding:8px 12px; font-size:10px; color:rgba(255,255,255,.6); }
      #avatar{ width:56px; height:56px; }
    }

    /* On touch/mobile: hide HUD title & Bryan, keep back button */
    @media (pointer:coarse){
      .hudTitle{ display:none; }
      #bryanBtn{ display:none; }
      #hud{ display:none; }
    }

    /* Hide BRYAN + HUD during transition (video + overlay 2) */
    #app.inTransition #bryanBtn,
    #app.inTransition #hud,
    #app.inTransition #avatar,
    #app.inTransition #backBtn{ display:none !important; }

    /* â”€â”€ FADE â”€â”€ */
    #fade{
      position:fixed; inset:0; background:#000; opacity:0;
      pointer-events:none; transition:opacity 520ms ease; z-index:200;
    }
    #fade.on{ opacity:1; }

    @media (prefers-reduced-motion:reduce){
      #avatar,#startGhost{ animation:none; }
      .rotateIcon{ animation:none; transform:rotate(-90deg); }
      #fade{ transition:none; }
      .sp{ animation:none; opacity:.6; }
    }
  </style>
</head>
<body>
<div id="app">

  <!-- ROTATE OVERLAY -->
  <div id="rotateOverlay" role="alert" aria-live="polite">
    <span class="rotateIcon">ğŸ“±</span>
    <h1 class="rotateTitle">ã‚ˆã“ã‚€ãã«ã—ã¦ã­ï¼</h1>
    <p class="rotateSub">ã‚ã„ã‚ã‚’ã‚ãã¶ã«ã¯<br>ã‚¹ãƒãƒ›ã‚’ã‚ˆã“ã«ã‚€ã‘ã¦ãã ã•ã„ã€‚</p>
  </div>

  <!-- OVERLAY 1 â€” confirmation -->
  <div id="overlay1" class="overlay" aria-label="ã‚ã„ã‚ã¸ã„ãï¼Ÿ">
    <h1 class="overlayHeading">ãƒ–ãƒ¼ãƒãƒ¼ã‚ã„ã‚ã«ã„ãï¼Ÿ</h1>
    <div class="btnRow">
      <button id="returnBtn" class="btnBlue" type="button">ã„ã‹ãªã„</button>
      <div class="sparkleWrap">
        <div class="sparkleField" id="confirmSparkles" aria-hidden="true"></div>
        <button id="continueBtn" class="btnPink" type="button">ã„ãï¼</button>
      </div>
    </div>
  </div>

  <!-- TRANSITION VIDEO -->
  <div id="videoWrap" aria-hidden="true">
    <video id="toMazeVideo" preload="auto" playsinline webkit-playsinline>
      <source src="assets/video/to-the-maze.mp4" type="video/mp4" />
    </video>
  </div>

  <!-- OVERLAY 2 â€” ghost start -->
  <div id="overlay2" class="overlay" aria-label="ã‚¹ã‚¿ãƒ¼ãƒˆ">
    <h1 class="overlayHeading">ãƒ–ãƒ¼ãƒãƒ¼ã‚’ã‚¿ãƒƒãƒã—ã¦ã¯ã˜ã‚ã‚ˆã†ï¼</h1>
    <button id="mazeStartBtn" class="ghostBtnWrap" type="button" aria-label="ã‚¹ã‚¿ãƒ¼ãƒˆ">
      <div class="ghostSparkleField" id="startSparkles" aria-hidden="true"></div>
      <img id="startGhost" alt="ãƒ–ãƒ¼ãƒãƒ¼" />
    </button>
  </div>

  <!-- MAZE SCENE -->
  <section id="mazeScene" aria-label="ã‚ã„ã‚">
    <div id="stage">
      <img id="mazeImg" src="assets/img/maze.png" alt="ã‚ã„ã‚" />
      <div id="hitLayer" aria-hidden="true">
        <div id="grid"></div>
        <div id="crosshair">
          <div class="chLineH"></div>
          <div class="chLineV"></div>
        </div>
      </div>
    </div>

    <!-- Desktop HUD (hidden on touch devices) -->
    <div id="hud">
      <div class="hudTitle">BOOHA<br>ADVENTURE</div>
      <div id="coordPill" class="pill">
        <div class="coordSmall">COORDINATES</div>
        <div class="coordBig" id="coordText">x: â€”  y: â€”</div>
        <div class="coordSmall" style="margin-top:6px;opacity:.9;">click to copy</div>
      </div>
    </div>

    <!-- Ghost avatar floating top-right (desktop) -->
    <img id="avatar" alt="ãƒ–ãƒ¼ãƒãƒ¼" />

    <!-- Bryan mode (desktop only) -->
    <button id="bryanBtn" type="button" aria-label="Bryan mode">BRYAN</button>

    <!-- Back â€” always visible, small on mobile -->
    <button id="backBtn" type="button" aria-label="ã‚‚ã©ã‚‹">ã‚‚ã©ã‚‹</button>
  </section>

  <div id="fade" aria-hidden="true"></div>
</div>

<audio id="bgMusic" src="assets/audio/sneaky.mp3" loop preload="auto"></audio>

<script>
  const BRYAN_PASS = 'him141amra803';
  const GHOSTS = [
    'assets/img/booha_ghost.png','assets/img/blue-boo.png',
    'assets/img/green-boo.png','assets/img/pink-boo.png','assets/img/purple-boo.png'
  ];

  const app             = document.getElementById('app');
  const rotateOverlay   = document.getElementById('rotateOverlay');
  const overlay1        = document.getElementById('overlay1');
  const overlay2        = document.getElementById('overlay2');
  const videoWrap       = document.getElementById('videoWrap');
  const toMazeVideo     = document.getElementById('toMazeVideo');
  const returnBtn       = document.getElementById('returnBtn');
  const continueBtn     = document.getElementById('continueBtn');
  const mazeStartBtn    = document.getElementById('mazeStartBtn');
  const startGhost      = document.getElementById('startGhost');
  const confirmSparkles = document.getElementById('confirmSparkles');
  const startSparkles   = document.getElementById('startSparkles');
  const fade            = document.getElementById('fade');
  const bgMusic         = document.getElementById('bgMusic');
  const avatar          = document.getElementById('avatar');
  const mazeImg         = document.getElementById('mazeImg');
  const hitLayer        = document.getElementById('hitLayer');
  const grid            = document.getElementById('grid');
  const crosshair       = document.getElementById('crosshair');
  const bryanBtn        = document.getElementById('bryanBtn');
  const backBtn         = document.getElementById('backBtn');
  const coordPill       = document.getElementById('coordPill');
  const coordText       = document.getElementById('coordText');
  const FADE_MS         = 520;

  // â”€â”€ Orientation / rotate overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Pure viewport check â€” no userAgent sniffing.
  // Works in all browsers, webviews, and in-app browsers (Messenger, LINE, etc.)
  // Only show rotate prompt when the screen is narrower than it is tall
  // AND the screen is small enough to be a phone/tablet (not a tall desktop window).
  function checkOrientation(){
    const portrait  = window.innerHeight > window.innerWidth;
    const smallScreen = window.innerWidth < 1024; // ignore tall narrow desktop windows
    rotateOverlay.classList.toggle('show', portrait && smallScreen);
  }
  window.addEventListener('resize', checkOrientation, {passive:true});
  window.addEventListener('orientationchange', ()=>setTimeout(checkOrientation,150), {passive:true});
  // Also fire on visualViewport changes (handles keyboard pop-up etc.)
  if(window.visualViewport){
    window.visualViewport.addEventListener('resize', checkOrientation, {passive:true});
  }
  checkOrientation();

  // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function fadeToBlack(on){ fade.classList.toggle('on', !!on); }
  function pickRandom(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

  function assignRandomGhost(){
    const src = pickRandom(GHOSTS);
    startGhost.src = avatar.src = src;
    const r = (Math.random()*10-5).toFixed(2)+'deg';
    avatar.style.setProperty('--r', r);
    startGhost.style.setProperty('--r', r);
  }

  // â”€â”€ Sparkle builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function buildSparkles(container, count=24, wide=false){
    container.innerHTML='';
    for(let i=0; i<count; i++){
      const sp = document.createElement('div'); sp.className='sp';
      const angle  = (i/count)*Math.PI*2;
      const radius = wide ? 35+Math.random()*28 : 28+Math.random()*18;
      const cx = 50+Math.cos(angle)*radius;
      const cy = 50+Math.sin(angle)*radius;
      const size  = wide ? 3+Math.random()*4 : 2+Math.random()*3;
      const dur   = 1.3+Math.random()*1.8;
      const delay = -(Math.random()*dur);
      sp.style.cssText = `--size:${size}px;--x:${cx}%;--y:${cy}%;--dur:${dur}s;--delay:${delay}s;`;
      container.appendChild(sp);
    }
  }
  buildSparkles(confirmSparkles, 24);
  buildSparkles(startSparkles, 36, true);

  // â”€â”€ Hit layer positioning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Always uses contain coordinates â€” no cover offset needed.
  function positionHitLayer(){
    const r = mazeImg.getBoundingClientRect();
    const s = document.getElementById('stage').getBoundingClientRect();
    hitLayer.style.left   = (r.left - s.left)+'px';
    hitLayer.style.top    = (r.top  - s.top )+'px';
    hitLayer.style.width  = r.width +'px';
    hitLayer.style.height = r.height+'px';
  }
  function positionSoon(){
    requestAnimationFrame(()=>requestAnimationFrame(positionHitLayer));
  }
  window.addEventListener('resize', positionSoon, {passive:true});
  window.addEventListener('orientationchange', ()=>setTimeout(positionSoon,200), {passive:true});
  if(mazeImg.complete) setTimeout(positionSoon, 0);
  else mazeImg.addEventListener('load', ()=>setTimeout(positionSoon, 0));

  // â”€â”€ Overlay 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  returnBtn.addEventListener('click', ()=>{
    fadeToBlack(true);
    setTimeout(()=>{ window.location.href='index.html'; }, FADE_MS);
  });

  let videoPlayed = false;
  continueBtn.addEventListener('click', async ()=>{
    if(videoPlayed) return; videoPlayed = true;

    overlay1.classList.add('hidden');
    overlay1.addEventListener('transitionend', ()=>overlay1.classList.add('gone'), {once:true});

    // Hide maze chrome while video plays
    app.classList.add('inTransition');

    videoWrap.classList.add('show');
    try{ toMazeVideo.currentTime = 0; }catch(e){}
    try{ await toMazeVideo.play(); }catch(e){ showOverlay2(); }
  });

  // â”€â”€ Video â†’ Overlay 2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let overlay2Shown = false;
  function showOverlay2(){
    if(overlay2Shown) return; overlay2Shown = true;
    try{ toMazeVideo.pause(); }catch(e){}
    try{ toMazeVideo.currentTime = 0; }catch(e){}
    videoWrap.classList.remove('show');
    overlay2.classList.add('show');
    app.classList.add('inTransition'); // still pre-maze
    positionSoon();
  }
  toMazeVideo.addEventListener('ended', showOverlay2);
  toMazeVideo.addEventListener('error', showOverlay2);
  toMazeVideo.addEventListener('timeupdate', ()=>{
    const d = toMazeVideo.duration;
    if(!isFinite(d) || d<=0) return;
    if(d - toMazeVideo.currentTime <= 0.5) showOverlay2();
  });

  // â”€â”€ Overlay 2 â†’ maze start â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let mazeStarted = false;
  mazeStartBtn.addEventListener('click', async ()=>{
    if(mazeStarted) return; mazeStarted = true;

    overlay2.classList.add('hidden');
    overlay2.addEventListener('transitionend', ()=>overlay2.remove(), {once:true});

    // Reveal maze chrome
    app.classList.remove('inTransition');

    // sneaky.mp3 â€” gesture unlocks audio
    try{ bgMusic.volume=0.65; await bgMusic.play(); }
    catch(e){ console.warn('Music blocked:', e); }

    positionSoon();
  });

  // â”€â”€ Back button (always visible) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  backBtn.addEventListener('click', ()=>{
    try{ bgMusic.pause(); bgMusic.currentTime=0; }catch(e){}
    fadeToBlack(true);
    setTimeout(()=>{ window.location.href='index.html'; }, FADE_MS);
  });

  // â”€â”€ Visibility â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  document.addEventListener('visibilitychange', ()=>{
    if(document.hidden){
      try{ toMazeVideo.pause(); }catch(e){}
      try{ bgMusic.pause(); }catch(e){}
    } else {
      if(videoPlayed && !overlay2Shown) try{ toMazeVideo.play(); }catch(e){}
      if(mazeStarted)                   try{ bgMusic.play(); }catch(e){}
    }
  });

  // â”€â”€ Bryan mode (desktop only) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let bryanOn = false;
  function applyBryanUI(){
    bryanBtn.classList.toggle('on', bryanOn);
    grid.classList.toggle('show', bryanOn);
    coordPill.classList.toggle('show', bryanOn);
    crosshair.classList.toggle('show', bryanOn);
    hitLayer.style.cursor = bryanOn ? 'crosshair' : 'default';
    if(bryanOn) requestAnimationFrame(positionHitLayer);
  }
  const dotLayer = document.createElement('div');
  dotLayer.style.cssText = 'position:absolute;inset:0;pointer-events:none;';
  hitLayer.appendChild(dotLayer);

  function placeDot(lx,ly,ix,iy){
    const dot = document.createElement('div');
    dot.style.cssText = `
      position:absolute; left:${lx}px; top:${ly}px;
      width:10px; height:10px; border-radius:50%;
      background:#ff3bbd;
      box-shadow:0 0 0 2px #fff,0 0 10px rgba(255,59,189,.8);
      transform:translate(-50%,-50%); pointer-events:none;`;
    const label = document.createElement('div');
    label.textContent = `${ix},${iy}`;
    label.style.cssText = `
      position:absolute; left:10px; top:-8px;
      font-size:11px; font-weight:900; letter-spacing:.5px;
      color:#fff; background:rgba(0,0,0,.72);
      padding:2px 5px; border-radius:4px;
      white-space:nowrap; pointer-events:none;`;
    dot.appendChild(label);
    dotLayer.appendChild(dot);
  }
  function clearDots(){ dotLayer.innerHTML=''; }

  bryanBtn.addEventListener('click', ()=>{
    if(bryanOn){
      bryanOn=false; clearDots();
      coordText.textContent='x: â€”  y: â€”';
      applyBryanUI(); return;
    }
    const pw = prompt('Bryan mode password:');
    if(pw===null) return;
    String(pw).trim()===BRYAN_PASS ? (bryanOn=true, applyBryanUI()) : alert('Nope.');
  });

  // â”€â”€ Coordinate finder (contain only â€” no cover math) â”€â”€â”€â”€â”€
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

  function getImageCoords(cx,cy){
    const rect = hitLayer.getBoundingClientRect();
    const lx = cx - rect.left;
    const ly = cy - rect.top;
    const x  = Math.round(clamp(lx/rect.width,  0,1) * (mazeImg.naturalWidth  ||0));
    const y  = Math.round(clamp(ly/rect.height, 0,1) * (mazeImg.naturalHeight ||0));
    return { x, y, localX:lx, localY:ly };
  }

  function setCrosshair(lx,ly){
    const h = crosshair.querySelector('.chLineH');
    const v = crosshair.querySelector('.chLineV');
    if(h) h.style.transform=`translateY(${ly}px)`;
    if(v) v.style.transform=`translateX(${lx}px)`;
  }

  async function copyText(txt){
    try{ await navigator.clipboard.writeText(txt); return true; }
    catch(e){
      try{
        const ta = document.createElement('textarea');
        ta.value=txt; ta.style.cssText='position:fixed;left:-9999px';
        document.body.appendChild(ta); ta.focus(); ta.select();
        document.execCommand('copy'); document.body.removeChild(ta); return true;
      }catch(err){ return false; }
    }
  }

  hitLayer.addEventListener('mousemove', e=>{
    if(!bryanOn) return;
    const c = getImageCoords(e.clientX, e.clientY);
    coordText.textContent = `x: ${c.x}  y: ${c.y}`;
    setCrosshair(c.localX, c.localY);
  });

  hitLayer.addEventListener('click', async e=>{
    if(!bryanOn) return;
    const c  = getImageCoords(e.clientX, e.clientY);
    coordText.textContent = `x: ${c.x}  y: ${c.y}`;
    setCrosshair(c.localX, c.localY);
    placeDot(c.localX, c.localY, c.x, c.y);
    const ok = await copyText(`${c.x},${c.y}`);
    if(ok){
      coordPill.style.transform='scale(1.02)';
      setTimeout(()=>coordPill.style.transform='', 120);
    }
  });

  coordPill.addEventListener('click', async ()=>{
    if(!bryanOn) return;
    const m = coordText.textContent.match(/x:\s*(\d+)\s*y:\s*(\d+)/);
    await copyText(m ? `${m[1]},${m[2]}` : coordText.textContent);
  });

  // â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  assignRandomGhost();
  positionSoon();
</script>
</body>
</html>
