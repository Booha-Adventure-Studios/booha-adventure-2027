
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Booha Adventure 2027 — Maze</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Bowlby+One&display=swap" rel="stylesheet" />
  <style>
    :root{
      --bg:#000;
      --text:#fff;
      --muted:rgba(255,255,255,.65);
      --pink:#ff3bbd;
      --pink2:#ff79d7;
      --safe-top: env(safe-area-inset-top);
      --safe-right: env(safe-area-inset-right);
      --safe-bottom: env(safe-area-inset-bottom);
      --safe-left: env(safe-area-inset-left);
    }

    *{ box-sizing:border-box; }
    html,body{
      height:100%; margin:0;
      background:var(--bg); color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial,
        "Noto Sans", "Hiragino Kaku Gothic ProN", "Yu Gothic", sans-serif;
    }

    #app{ position:fixed; inset:0; background:#000; overflow:hidden; }

    /* ── Scenes ── */
    .scene{ position:absolute; inset:0; display:none; }
    .scene.active{ display:block; }

    /* ══════════════════════════════
       VIDEO SCENE (intro transition)
    ══════════════════════════════ */
    #videoScene{ background:#000; }

    #toMazeVideo{
      width:100%; height:100%;
      object-fit:cover;
      background:#000;
    }

    /* Tap-to-play fallback (only shows if autoplay is blocked) */
    #tapOverlay{
      position:absolute; inset:0;
      display:none;
      align-items:center; justify-content:center;
      padding: calc(24px + var(--safe-top)) calc(24px + var(--safe-right))
               calc(24px + var(--safe-bottom)) calc(24px + var(--safe-left));
      background: radial-gradient(ellipse at center,
        rgba(0,0,0,.55) 0%,
        rgba(0,0,0,.88) 70%,
        rgba(0,0,0,.95) 100%);
      text-align:center;
      z-index:5;
    }
    #tapOverlay.show{ display:flex; }

    .tapCard{
      width:min(560px,100%);
      border-radius:26px;
      padding:22px 18px 18px;
      background: rgba(255,255,255,.08);
      backdrop-filter: blur(18px) saturate(150%);
      -webkit-backdrop-filter: blur(18px) saturate(150%);
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.18),
        0 20px 60px rgba(0,0,0,.7),
        0 0 0 2px rgba(255,59,189,.30),
        0 0 30px rgba(255,59,189,.25);
    }
    .tapTitle{
      font-family:'Bowlby One', system-ui, sans-serif;
      letter-spacing:2px; font-size:22px;
      margin:0 0 8px;
    }
    .tapSub{ margin:0 0 16px; color:var(--muted); line-height:1.35; }

    /* ══════════════════════════════
       MAZE SCENE
    ══════════════════════════════ */
    #mazeScene{ background:#000; }

    /* ── Start overlay (shown on top of maze until player taps START) ── */
    #startOverlay{
      position:absolute; inset:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:22px;
      padding: calc(24px + var(--safe-top)) calc(24px + var(--safe-right))
               calc(24px + var(--safe-bottom)) calc(24px + var(--safe-left));
      background: radial-gradient(ellipse at center,
        rgba(0,0,0,.45) 0%,
        rgba(0,0,0,.80) 60%,
        rgba(0,0,0,.93) 100%);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      text-align:center;
      z-index:30;
      transition: opacity 600ms ease;
    }
    #startOverlay.hidden{
      opacity:0;
      pointer-events:none;
    }

    /* Ghost on start overlay */
    #startGhost{
      width: min(28vmin, 220px);
      height: min(28vmin, 220px);
      object-fit:contain;
      user-select:none;
      -webkit-user-drag:none;
      filter:
        drop-shadow(0 0 22px rgba(255,100,220,.55))
        drop-shadow(0 14px 30px rgba(0,0,0,.7));
      animation: floaty 3.6s ease-in-out infinite;
      transform-origin: 50% 60%;
    }

    .startHeading{
      font-family:'Bowlby One', system-ui, sans-serif;
      font-size: clamp(28px, 4.5vw, 56px);
      letter-spacing:3px;
      color:#fff;
      text-shadow:
        0 0 32px rgba(255,140,255,.7),
        0 0 80px rgba(255,80,200,.35),
        0 2px 8px rgba(0,0,0,.9);
      margin:0;
    }

    .startSub{
      font-size:15px;
      color:rgba(255,255,255,.6);
      letter-spacing:.4px;
      margin:0;
    }

    /* Sparkle field for start overlay ghost */
    .startSparkleField{
      position:absolute;
      /* centred on the ghost — ghost is ~220px, field bleeds 60px past */
      width: calc(min(28vmin, 220px) + 120px);
      height: calc(min(28vmin, 220px) + 120px);
      pointer-events:none;
    }
    .sp{
      position:absolute;
      border-radius:50%;
      background:#fff;
      opacity:0;
      animation: sparkleLife var(--dur) ease-in-out var(--delay) infinite;
      width: var(--size); height: var(--size);
      top: var(--y); left: var(--x);
      box-shadow:
        0 0 4px 1px rgba(255,255,255,.9),
        0 0 10px 3px rgba(255,100,220,.6);
    }
    @keyframes sparkleLife{
      0%  { opacity:0;   transform: scale(.4) translateY(0); }
      20% { opacity:1;   transform: scale(1)  translateY(-6px); }
      60% { opacity:.85; transform: scale(.9) translateY(-14px); }
      100%{ opacity:0;   transform: scale(.3) translateY(-22px); }
    }

    /* Maze image stage */
    #stage{
      position:absolute; inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: calc(10px + var(--safe-top)) calc(10px + var(--safe-right))
               calc(10px + var(--safe-bottom)) calc(10px + var(--safe-left));
    }

    #mazeImg{
      width:100%; height:100%;
      max-width:100%; max-height:100%;
      object-fit:contain;
      user-select:none;
      -webkit-user-drag:none;
      pointer-events:none;
      filter: drop-shadow(0 18px 40px rgba(0,0,0,.6));
    }

    /* Hit layer — sized/positioned in JS to match image rect */
    #hitLayer{
      position:absolute;
      left:0; top:0; width:0; height:0;
      cursor:default;
      z-index:5;
      pointer-events:auto;
    }

    /* Grid + crosshair (Bryan mode) */
    #grid{
      position:absolute; inset:0;
      display:none;
      pointer-events:none;
      background-image:
        linear-gradient(to right,  rgba(255,255,255,.12) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(255,255,255,.12) 1px, transparent 1px);
      background-size: 80px 80px;
      mix-blend-mode:screen;
      opacity:.55;
    }
    #grid.show{ display:block; }

    #crosshair{
      position:absolute; inset:0;
      pointer-events:none;
      display:none;
    }
    #crosshair.show{ display:block; }
    .chLineH,.chLineV{
      position:absolute;
      background:rgba(255,255,255,.7);
      box-shadow:0 0 16px rgba(255,255,255,.25);
    }
    .chLineH{ height:1px; left:0; right:0; top:0; }
    .chLineV{ width:1px;  top:0; bottom:0; left:0; }

    /* HUD title — Bowlby One, matches maze heading style */
    .hudTitle{
      font-family: 'Bowlby One', system-ui, sans-serif;
      font-size: clamp(13px, 1.8vw, 18px);
      letter-spacing: 2px;
      line-height: 1.15;
      color: #fff;
      text-shadow:
        0 0 22px rgba(255,140,255,.7),
        0 0 60px rgba(255,80,200,.35),
        0 2px 6px rgba(0,0,0,.9);
      user-select: none;
      pointer-events: none;
    }

    /* HUD (top-left) */
    #hud{
      position:absolute;
      left: calc(12px + var(--safe-left));
      top:  calc(12px + var(--safe-top));
      display:flex; gap:10px; align-items:flex-start;
      z-index:10;
    }

    .pill{
      border-radius:999px;
      padding:10px 14px;
      font-weight:900; letter-spacing:.4px;
      background: rgba(0,0,0,.28);
      border:1px solid rgba(255,255,255,.16);
      backdrop-filter: blur(14px) saturate(140%);
      -webkit-backdrop-filter: blur(14px) saturate(140%);
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,.08),
        0 14px 30px rgba(0,0,0,.35);
      color:rgba(255,255,255,.92);
      user-select:none;
    }

    #coordPill{ display:none; }
    #coordPill.show{ display:block; }
    .coordSmall{ font-size:12px; color:rgba(255,255,255,.7); font-weight:800; letter-spacing:1px; }
    .coordBig{ font-size:14px; margin-top:4px; }

    /* Floating ghost avatar (top-right) */
    #avatar{
      position:absolute;
      right: calc(12px + var(--safe-right));
      top:   calc(12px + var(--safe-top));
      width:64px; height:64px;
      z-index:20;
      pointer-events:none;
      filter: drop-shadow(0 16px 30px rgba(0,0,0,.55));
      opacity:.98;
      transform-origin:50% 60%;
      animation: floaty 3.8s ease-in-out infinite;
    }

    @keyframes floaty{
      0%  { transform: translateY(0px)   rotate(var(--r,0deg)); }
      50% { transform: translateY(-10px) rotate(calc(var(--r,0deg) + 2deg)); }
      100%{ transform: translateY(0px)   rotate(var(--r,0deg)); }
    }

    /* Bottom-left BRYAN button */
    #bryanBtn{
      position:absolute;
      left: calc(12px + var(--safe-left));
      bottom: calc(12px + var(--safe-bottom));
      z-index:20;
      border-radius:999px;
      padding:10px 12px;
      font-size:12px; font-weight:1000; letter-spacing:1.6px;
      text-transform:uppercase;
      color:rgba(255,255,255,.75);
      background:rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(10px) saturate(140%);
      -webkit-backdrop-filter: blur(10px) saturate(140%);
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
    }
    #bryanBtn.on{
      color:#fff;
      border-color:rgba(255,255,255,.22);
      box-shadow:
        0 0 0 2px rgba(255,59,189,.18),
        0 0 26px rgba(255,59,189,.25);
    }
    #bryanBtn:active{ transform:scale(.99); }

    /* Bottom-right BACK button — glowing pink, Japanese */
    #backBtn{
      position:absolute;
      right: calc(12px + var(--safe-right));
      bottom: calc(12px + var(--safe-bottom));
      z-index:20;
      appearance:none; border:0;
      border-radius:999px;
      padding:12px 20px;
      font-size:15px; font-weight:1000; letter-spacing:.6px;
      cursor:pointer; color:#000;
      background: linear-gradient(180deg, var(--pink2), var(--pink));
      box-shadow:
        0 8px 20px rgba(255,59,189,.30),
        0 0 0 2px rgba(255,59,189,.18),
        0 0 28px rgba(255,59,189,.40);
      -webkit-tap-highlight-color: transparent;
      transform: translateZ(0);
    }
    #backBtn:active{ transform: scale(.98); }

    /* Shared button style */
    .btn{
      appearance:none; border:0;
      border-radius:999px;
      padding:14px 20px;
      font-size:18px; font-weight:1000; letter-spacing:.6px;
      cursor:pointer; color:#000;
      background: linear-gradient(180deg, var(--pink2), var(--pink));
      box-shadow:
        0 10px 22px rgba(255,59,189,.28),
        0 0 0 2px rgba(255,59,189,.15),
        0 0 26px rgba(255,59,189,.35);
      -webkit-tap-highlight-color: transparent;
      transform: translateZ(0);
    }
    .btn:active{ transform: scale(.98); }

    /* Fade layer */
    #fade{
      position:absolute; inset:0;
      background:#000; opacity:0;
      pointer-events:none;
      transition: opacity 520ms ease;
      z-index:100;
    }
    #fade.on{ opacity:1; }

    @media (prefers-reduced-motion: reduce){
      #avatar, #startGhost{ animation:none; }
      #fade{ transition:none; }
    }
  </style>
</head>
<body>
<div id="app">

  <!-- ── VIDEO SCENE (transition from index) ── -->
  <section id="videoScene" class="scene active" aria-label="To the maze video">
    <video id="toMazeVideo" preload="auto" playsinline webkit-playsinline>
      <source src="assets/video/to-the-maze.mp4" type="video/mp4" />
    </video>

    <!-- Shown only if autoplay is blocked -->
    <div id="tapOverlay" aria-hidden="true">
      <div class="tapCard">
        <h1 class="tapTitle">ブーハーめいろ</h1>
        <p class="tapSub">タップしてめいろへ入ろう！</p>
        <button id="tapBtn" class="btn" type="button">はいる</button>
      </div>
    </div>
  </section>

  <!-- ── MAZE SCENE ── -->
  <section id="mazeScene" class="scene" aria-label="Maze">

    <!-- Maze image -->
    <div id="stage">
      <img id="mazeImg" src="assets/img/maze.png" alt="Maze" />
      <div id="hitLayer" aria-hidden="true">
        <div id="grid"></div>
        <div id="crosshair">
          <div class="chLineH"></div>
          <div class="chLineV"></div>
        </div>
      </div>
    </div>

    <!-- HUD (top-left) -->
    <div id="hud">
      <div class="hudTitle">BOOHA<br>ADVENTURE</div>
      <div id="coordPill" class="pill">
        <div class="coordSmall">COORDINATES</div>
        <div class="coordBig" id="coordText">x: —  y: —</div>
        <div class="coordSmall" style="margin-top:6px;opacity:.9;">click to copy</div>
      </div>
    </div>

    <!-- Floating ghost avatar (top-right, visible after start) -->
    <img id="avatar" alt="Booha" />

    <!-- Bryan mode toggle (bottom-left) -->
    <button id="bryanBtn" type="button" aria-label="Bryan mode">BRYAN</button>

    <!-- Back button (bottom-right) -->
    <button id="backBtn" type="button" aria-label="Back">もどる</button>

    <!-- ── START OVERLAY (shown until player taps START) ── -->
    <div id="startOverlay" aria-label="Start maze">
      <!-- sparkles behind ghost -->
      <div class="startSparkleField" id="startSparkleField" aria-hidden="true"></div>

      <img id="startGhost" alt="Booha" />

      <h1 class="startHeading">BOOHA MAZE</h1>
      <p class="startSub">めいろをはじめよう！</p>

      <button id="mazeStartBtn" class="btn" type="button">スタート</button>
    </div>

  </section>

  <div id="fade" aria-hidden="true"></div>
</div>

<audio id="bgMusic" src="assets/audio/sneaky.mp3" loop preload="auto"></audio>

<script>
  // ─────────────────────────────────────────────────────────
  // CONFIG
  // ─────────────────────────────────────────────────────────
  const BRYAN_PASS = 'him141amra803';
  const BRYAN_KEY  = 'booha_bryan_mode_unlocked_v1';

  const GHOSTS = [
    'assets/img/booha_ghost.png',
    'assets/img/blue-boo.png',
    'assets/img/green-boo.png',
    'assets/img/pink-boo.png',
    'assets/img/purple-boo.png'
  ];

  // ─────────────────────────────────────────────────────────
  // Element refs
  // ─────────────────────────────────────────────────────────
  const videoScene    = document.getElementById('videoScene');
  const mazeScene     = document.getElementById('mazeScene');
  const toMazeVideo   = document.getElementById('toMazeVideo');
  const tapOverlay    = document.getElementById('tapOverlay');
  const tapBtn        = document.getElementById('tapBtn');
  const fade          = document.getElementById('fade');

  const mazeImg       = document.getElementById('mazeImg');
  const hitLayer      = document.getElementById('hitLayer');
  const grid          = document.getElementById('grid');
  const crosshair     = document.getElementById('crosshair');

  const bryanBtn      = document.getElementById('bryanBtn');
  const backBtn       = document.getElementById('backBtn');
  const avatar        = document.getElementById('avatar');

  const coordPill     = document.getElementById('coordPill');
  const coordText     = document.getElementById('coordText');

  const startOverlay  = document.getElementById('startOverlay');
  const startGhost    = document.getElementById('startGhost');
  const mazeStartBtn  = document.getElementById('mazeStartBtn');
  const startSparkles = document.getElementById('startSparkleField');

  const bgMusic       = document.getElementById('bgMusic');

  // ─────────────────────────────────────────────────────────
  // Helpers
  // ─────────────────────────────────────────────────────────
  function showScene(el){
    [videoScene, mazeScene].forEach(s => s.classList.remove('active'));
    el.classList.add('active');
  }

  function fadeToBlack(on=true){
    fade.classList.toggle('on', !!on);
  }

  function pickRandom(arr){
    return arr[Math.floor(Math.random() * arr.length)];
  }

  // Pick a random ghost and apply it to both the start overlay
  // ghost and the floating HUD avatar
  function assignRandomGhost(){
    const src = pickRandom(GHOSTS);
    startGhost.src = src;
    avatar.src     = src;
    const r = (Math.random() * 10 - 5).toFixed(2) + 'deg';
    avatar.style.setProperty('--r', r);
    startGhost.style.setProperty('--r', r);
  }

  // ─────────────────────────────────────────────────────────
  // Sparkles on start overlay
  // ─────────────────────────────────────────────────────────
  (function initStartSparkles(){
    if (!startSparkles) return;
    const COUNT = 28;
    startSparkles.innerHTML = '';
    for (let i = 0; i < COUNT; i++){
      const sp = document.createElement('div');
      sp.className = 'sp';
      const angle  = (i / COUNT) * Math.PI * 2;
      const radius = 30 + Math.random() * 20;
      const cx     = 50 + Math.cos(angle) * radius;
      const cy     = 50 + Math.sin(angle) * radius;
      const size   = 2 + Math.random() * 3;
      const dur    = 1.4 + Math.random() * 2.0;
      const delay  = -(Math.random() * dur);
      sp.style.cssText = `
        --size:${size}px; --x:${cx}%; --y:${cy}%;
        --dur:${dur}s; --delay:${delay}s;
      `;
      startSparkles.appendChild(sp);
    }
  })();

  // ─────────────────────────────────────────────────────────
  // Bryan mode
  // ─────────────────────────────────────────────────────────
  function isBryanUnlocked(){
    try { return localStorage.getItem(BRYAN_KEY) === '1'; } catch(e){ return false; }
  }
  function setBryanUnlocked(on){
    try { localStorage.setItem(BRYAN_KEY, on ? '1' : '0'); } catch(e){}
  }
  function applyBryanUI(){
    const on = isBryanUnlocked();
    bryanBtn.classList.toggle('on', on);
    grid.classList.toggle('show', on);
    coordPill.classList.toggle('show', on);
    crosshair.classList.toggle('show', on);
    hitLayer.style.cursor = on ? 'crosshair' : 'default';
    // Re-sync hit layer size whenever mode changes
    if (on) requestAnimationFrame(() => positionHitLayer());
  }

  bryanBtn.addEventListener('click', () => {
    if (isBryanUnlocked()){
      setBryanUnlocked(false);
      applyBryanUI();
      return;
    }
    const pw = prompt('Bryan mode password:');
    if (pw === null) return;
    if (String(pw).trim() === BRYAN_PASS){
      setBryanUnlocked(true);
      applyBryanUI();
      alert('Bryan mode unlocked.');
    } else {
      alert('Nope.');
    }
  });

  // ─────────────────────────────────────────────────────────
  // Hit layer / coordinate finder
  // ─────────────────────────────────────────────────────────
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function positionHitLayer(){
    const r      = mazeImg.getBoundingClientRect();
    const stageR = document.getElementById('stage').getBoundingClientRect();
    hitLayer.style.left   = (r.left - stageR.left) + 'px';
    hitLayer.style.top    = (r.top  - stageR.top)  + 'px';
    hitLayer.style.width  = r.width  + 'px';
    hitLayer.style.height = r.height + 'px';
  }

  function getImageCoords(clientX, clientY){
    const rect = hitLayer.getBoundingClientRect();
    const x  = clientX - rect.left;
    const y  = clientY - rect.top;
    const nx = clamp(x / rect.width,  0, 1);
    const ny = clamp(y / rect.height, 0, 1);
    return {
      x: Math.round(nx * (mazeImg.naturalWidth  || 0)),
      y: Math.round(ny * (mazeImg.naturalHeight || 0)),
      localX: x, localY: y
    };
  }

  function setCrosshair(lx, ly){
    const h = crosshair.querySelector('.chLineH');
    const v = crosshair.querySelector('.chLineV');
    if (h) h.style.transform = `translateY(${ly}px)`;
    if (v) v.style.transform = `translateX(${lx}px)`;
  }

  async function copyText(txt){
    try {
      await navigator.clipboard.writeText(txt);
      return true;
    } catch(e){
      try {
        const ta = document.createElement('textarea');
        ta.value = txt; ta.style.position='fixed'; ta.style.left='-9999px';
        document.body.appendChild(ta); ta.focus(); ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        return true;
      } catch(err){ return false; }
    }
  }

  hitLayer.addEventListener('mousemove', e => {
    if (!isBryanUnlocked()) return;
    const c = getImageCoords(e.clientX, e.clientY);
    coordText.textContent = `x: ${c.x}  y: ${c.y}`;
    setCrosshair(c.localX, c.localY);
  });

  hitLayer.addEventListener('click', async e => {
    if (!isBryanUnlocked()) return;
    const c   = getImageCoords(e.clientX, e.clientY);
    const txt = `${c.x},${c.y}`;
    coordText.textContent = `x: ${c.x}  y: ${c.y}`;
    setCrosshair(c.localX, c.localY);
    const ok = await copyText(txt);
    if (ok){
      coordPill.style.transform = 'scale(1.02)';
      setTimeout(() => coordPill.style.transform = '', 120);
    }
  });

  coordPill.addEventListener('click', async () => {
    if (!isBryanUnlocked()) return;
    const m   = coordText.textContent.match(/x:\s*(\d+)\s*y:\s*(\d+)/);
    const out = m ? `${m[1]},${m[2]}` : coordText.textContent;
    await copyText(out);
  });

  window.addEventListener('resize', positionHitLayer, { passive:true });

  if (mazeImg.complete){ setTimeout(positionHitLayer, 0); }
  else { mazeImg.addEventListener('load', () => setTimeout(positionHitLayer, 0)); }

  // ─────────────────────────────────────────────────────────
  // Video → Maze scene transition
  // ─────────────────────────────────────────────────────────
  const FADE_MS = 520;
  let going = false;

  function enterMazeScene(){
    if (going) return;
    going = true;
    fadeToBlack(true);
    setTimeout(() => {
      showScene(mazeScene);
      // Re-position hit layer NOW that maze scene is visible and image has a rendered size
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          positionHitLayer();
          fadeToBlack(false);
          going = false;
        });
      });
    }, FADE_MS);
  }

  async function tryAutoPlay(){
    try { toMazeVideo.currentTime = 0; } catch(e){}
    try {
      await toMazeVideo.play();
      // Autoplay with audio succeeded (desktop/some Android)
      tapOverlay.classList.remove('show');
      tapOverlay.setAttribute('aria-hidden','true');
    } catch(e){
      // Blocked (iOS always blocks audio autoplay without gesture)
      // Show tap overlay immediately — user taps ENTER to start video + audio
      tapOverlay.classList.add('show');
      tapOverlay.setAttribute('aria-hidden','false');
    }
  }

  toMazeVideo.addEventListener('timeupdate', () => {
    const d = toMazeVideo.duration;
    if (!isFinite(d) || d <= 0) return;
    if (d - toMazeVideo.currentTime <= 0.85) enterMazeScene();
  });
  toMazeVideo.addEventListener('ended', enterMazeScene);
  toMazeVideo.addEventListener('error', enterMazeScene);

  tapBtn.addEventListener('click', async () => {
    tapOverlay.classList.remove('show');
    tapOverlay.setAttribute('aria-hidden','true');
    try { await toMazeVideo.play(); }
    catch(e){ enterMazeScene(); }
  });

  document.addEventListener('visibilitychange', () => {
    if (document.hidden){
      try { toMazeVideo.pause(); } catch(e){}
      try { bgMusic.pause(); }     catch(e){}
    } else {
      // Resume music only if maze has started
      if (mazeStarted) try { bgMusic.play(); } catch(e){}
    }
  });

  // ─────────────────────────────────────────────────────────
  // START OVERLAY — shown when maze scene first appears
  // Player taps START → overlay fades out, music begins
  // ─────────────────────────────────────────────────────────
  let mazeStarted = false;

  mazeStartBtn.addEventListener('click', async () => {
    if (mazeStarted) return;
    mazeStarted = true;

    // Fade out overlay
    startOverlay.classList.add('hidden');

    // Start looping background music (user gesture required — this is it)
    try {
      bgMusic.volume = 0.65;
      await bgMusic.play();
    } catch(e){ console.warn('Music blocked:', e); }

    // Remove overlay from DOM after transition ends (keeps it clean)
    startOverlay.addEventListener('transitionend', () => {
      startOverlay.remove();
    }, { once: true });
  });

  // ─────────────────────────────────────────────────────────
  // Back button → return to index hub
  // ─────────────────────────────────────────────────────────
  backBtn.addEventListener('click', () => {
    // Stop music gracefully
    try { bgMusic.pause(); bgMusic.currentTime = 0; } catch(e){}

    fadeToBlack(true);
    setTimeout(() => {
      window.location.href = 'index.html';
    }, FADE_MS);
  });

  // ─────────────────────────────────────────────────────────
  // Init
  // ─────────────────────────────────────────────────────────
  assignRandomGhost();   // pick ghost for both overlay + avatar
  applyBryanUI();        // restore Bryan mode state from localStorage
  tryAutoPlay();         // kick off the intro video
</script>
</body>
</html>
